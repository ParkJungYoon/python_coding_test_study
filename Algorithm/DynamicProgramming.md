# 다이나믹 프로그래밍 (Dynamic Programming)

다이나믹 프로그래밍(=동적 계획법)은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법이다.
<br>

### 조건

1. **최적 부분 구조 (Optimal Substructure)**
   - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
2. **중복되는 부분 문제 (Overlapping Subproblem)**
   - 동일한 작은 문제를 반복적으로 해결해야 한다.

## 1. 피보나치 수열

### > 비효율적 해법 : 재귀

- 점화식: <u>인접한 항들 사이의 관계식</u>

$$a_{n} = a_{n-1} + a_{n-2}, a_{1} = 1, a_{2} = 1 $$

- 재귀 소스 코드

```py
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)

print(fibo(4))
```

```java
import java.util.*;

public class Main {
    public static int fibo(int x) {
        if (x == 1 || x ==2) {
            return 1;
        }
        return fibo(x-1) + fibo(x-2);
    }

    public static void main(String[] args) {
        System.out.println(fibo(4));
    }
}
```

- 시간 복잡도 분석
  - 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도
  - 여러 번 호출 => **중복되는 부분 문제**
  - **O((2<sup>N</sup>)**

<br>

### > 효율적인 해법: 다이나믹 프로그래밍

1. 조건 확인
   1. **최적 부분 구조** : 큰 문제를 작은 문제로 나눌 수 있다.
   2. **중복되는 부분 문제** : 동일한 작은 문제를 반복적으로 해결한다.
2. 구현

### 1) 하향식(탑다운) : 메모이제이션

한 번 계산한 결과를 메모리 공간에 메모하는 기법

- 캐싱

- 소스 코드

```py
# 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건 (1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
```

- 시간 복잡도
  - O(N)

<br>

### 2) 상향식(보텀업)

- 소스 코드

```py
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현 (보텀업 다이나믹 프로그래밍)
for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[n])
```

<br>

### <문제> 1로 만들기

#### ✔️ 문제 설명

- 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.
  1. X가 5로 나누어 떨어지면, 5로 나눈다.
  2. X가 3으로 나누어 떨어지면, 3으로 나눈다.
  3. X가 2로 나누어 떨어지면, 2로 나눈다.
  4. X에서 1을 뺀다.
- 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 값을 1로 만들고자 한다. 연산을 사용하는 횟수의 최솟값을 출력한다. 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
- 26 -> 25 -> 5 -> 1

#### 💡 문제 해결 아이디어

- 최적 부분 구조와 중복되는 부분 문제를 만족한다.
- 지금 당장은 5로 나누는 것이 더 좋아 보일지라도 다른 연산을 섞어서 더 최적의 해를 만들 수 있기 때문에 단순히 그리디 해법으로는 풀이가 어렵다.

#### 🐾 풀이 예시

- 파이썬

```python
# 정수 X를 입력 받기
x = int(input())

# 앞서 걔산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프록래밍 진행 (보텀업)
for i in range(2, x+1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i//2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i//5] + 1)

print(d[x])
```

---

## Reference & Additional Resources

- [한빛미디어] 이것이 취업을 위한 코딩 테스트다 with 파이썬 (나동빈 저)

```

```
